// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/endot1231/ec-backend/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/endot1231/ec-backend/ent/admins"
	"github.com/endot1231/ec-backend/ent/company"
	"github.com/endot1231/ec-backend/ent/productbrands"
	"github.com/endot1231/ec-backend/ent/productcategories"
	"github.com/endot1231/ec-backend/ent/productcolors"
	"github.com/endot1231/ec-backend/ent/products"
	"github.com/endot1231/ec-backend/ent/productsizes"
	"github.com/endot1231/ec-backend/ent/productstock"
	"github.com/endot1231/ec-backend/ent/reviews"
	"github.com/endot1231/ec-backend/ent/shops"
	"github.com/endot1231/ec-backend/ent/users"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Admins is the client for interacting with the Admins builders.
	Admins *AdminsClient
	// Company is the client for interacting with the Company builders.
	Company *CompanyClient
	// ProductBrands is the client for interacting with the ProductBrands builders.
	ProductBrands *ProductBrandsClient
	// ProductCategories is the client for interacting with the ProductCategories builders.
	ProductCategories *ProductCategoriesClient
	// ProductColors is the client for interacting with the ProductColors builders.
	ProductColors *ProductColorsClient
	// ProductSizes is the client for interacting with the ProductSizes builders.
	ProductSizes *ProductSizesClient
	// ProductStock is the client for interacting with the ProductStock builders.
	ProductStock *ProductStockClient
	// Products is the client for interacting with the Products builders.
	Products *ProductsClient
	// Reviews is the client for interacting with the Reviews builders.
	Reviews *ReviewsClient
	// Shops is the client for interacting with the Shops builders.
	Shops *ShopsClient
	// Users is the client for interacting with the Users builders.
	Users *UsersClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Admins = NewAdminsClient(c.config)
	c.Company = NewCompanyClient(c.config)
	c.ProductBrands = NewProductBrandsClient(c.config)
	c.ProductCategories = NewProductCategoriesClient(c.config)
	c.ProductColors = NewProductColorsClient(c.config)
	c.ProductSizes = NewProductSizesClient(c.config)
	c.ProductStock = NewProductStockClient(c.config)
	c.Products = NewProductsClient(c.config)
	c.Reviews = NewReviewsClient(c.config)
	c.Shops = NewShopsClient(c.config)
	c.Users = NewUsersClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Admins:            NewAdminsClient(cfg),
		Company:           NewCompanyClient(cfg),
		ProductBrands:     NewProductBrandsClient(cfg),
		ProductCategories: NewProductCategoriesClient(cfg),
		ProductColors:     NewProductColorsClient(cfg),
		ProductSizes:      NewProductSizesClient(cfg),
		ProductStock:      NewProductStockClient(cfg),
		Products:          NewProductsClient(cfg),
		Reviews:           NewReviewsClient(cfg),
		Shops:             NewShopsClient(cfg),
		Users:             NewUsersClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Admins:            NewAdminsClient(cfg),
		Company:           NewCompanyClient(cfg),
		ProductBrands:     NewProductBrandsClient(cfg),
		ProductCategories: NewProductCategoriesClient(cfg),
		ProductColors:     NewProductColorsClient(cfg),
		ProductSizes:      NewProductSizesClient(cfg),
		ProductStock:      NewProductStockClient(cfg),
		Products:          NewProductsClient(cfg),
		Reviews:           NewReviewsClient(cfg),
		Shops:             NewShopsClient(cfg),
		Users:             NewUsersClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Admins.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Admins, c.Company, c.ProductBrands, c.ProductCategories, c.ProductColors,
		c.ProductSizes, c.ProductStock, c.Products, c.Reviews, c.Shops, c.Users,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Admins, c.Company, c.ProductBrands, c.ProductCategories, c.ProductColors,
		c.ProductSizes, c.ProductStock, c.Products, c.Reviews, c.Shops, c.Users,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdminsMutation:
		return c.Admins.mutate(ctx, m)
	case *CompanyMutation:
		return c.Company.mutate(ctx, m)
	case *ProductBrandsMutation:
		return c.ProductBrands.mutate(ctx, m)
	case *ProductCategoriesMutation:
		return c.ProductCategories.mutate(ctx, m)
	case *ProductColorsMutation:
		return c.ProductColors.mutate(ctx, m)
	case *ProductSizesMutation:
		return c.ProductSizes.mutate(ctx, m)
	case *ProductStockMutation:
		return c.ProductStock.mutate(ctx, m)
	case *ProductsMutation:
		return c.Products.mutate(ctx, m)
	case *ReviewsMutation:
		return c.Reviews.mutate(ctx, m)
	case *ShopsMutation:
		return c.Shops.mutate(ctx, m)
	case *UsersMutation:
		return c.Users.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdminsClient is a client for the Admins schema.
type AdminsClient struct {
	config
}

// NewAdminsClient returns a client for the Admins from the given config.
func NewAdminsClient(c config) *AdminsClient {
	return &AdminsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `admins.Hooks(f(g(h())))`.
func (c *AdminsClient) Use(hooks ...Hook) {
	c.hooks.Admins = append(c.hooks.Admins, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `admins.Intercept(f(g(h())))`.
func (c *AdminsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Admins = append(c.inters.Admins, interceptors...)
}

// Create returns a builder for creating a Admins entity.
func (c *AdminsClient) Create() *AdminsCreate {
	mutation := newAdminsMutation(c.config, OpCreate)
	return &AdminsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Admins entities.
func (c *AdminsClient) CreateBulk(builders ...*AdminsCreate) *AdminsCreateBulk {
	return &AdminsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Admins.
func (c *AdminsClient) Update() *AdminsUpdate {
	mutation := newAdminsMutation(c.config, OpUpdate)
	return &AdminsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminsClient) UpdateOne(a *Admins) *AdminsUpdateOne {
	mutation := newAdminsMutation(c.config, OpUpdateOne, withAdmins(a))
	return &AdminsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminsClient) UpdateOneID(id int) *AdminsUpdateOne {
	mutation := newAdminsMutation(c.config, OpUpdateOne, withAdminsID(id))
	return &AdminsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Admins.
func (c *AdminsClient) Delete() *AdminsDelete {
	mutation := newAdminsMutation(c.config, OpDelete)
	return &AdminsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdminsClient) DeleteOne(a *Admins) *AdminsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdminsClient) DeleteOneID(id int) *AdminsDeleteOne {
	builder := c.Delete().Where(admins.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminsDeleteOne{builder}
}

// Query returns a query builder for Admins.
func (c *AdminsClient) Query() *AdminsQuery {
	return &AdminsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdmins},
		inters: c.Interceptors(),
	}
}

// Get returns a Admins entity by its id.
func (c *AdminsClient) Get(ctx context.Context, id int) (*Admins, error) {
	return c.Query().Where(admins.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminsClient) GetX(ctx context.Context, id int) *Admins {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdminsClient) Hooks() []Hook {
	return c.hooks.Admins
}

// Interceptors returns the client interceptors.
func (c *AdminsClient) Interceptors() []Interceptor {
	return c.inters.Admins
}

func (c *AdminsClient) mutate(ctx context.Context, m *AdminsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdminsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdminsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdminsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdminsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Admins mutation op: %q", m.Op())
	}
}

// CompanyClient is a client for the Company schema.
type CompanyClient struct {
	config
}

// NewCompanyClient returns a client for the Company from the given config.
func NewCompanyClient(c config) *CompanyClient {
	return &CompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `company.Hooks(f(g(h())))`.
func (c *CompanyClient) Use(hooks ...Hook) {
	c.hooks.Company = append(c.hooks.Company, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `company.Intercept(f(g(h())))`.
func (c *CompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Company = append(c.inters.Company, interceptors...)
}

// Create returns a builder for creating a Company entity.
func (c *CompanyClient) Create() *CompanyCreate {
	mutation := newCompanyMutation(c.config, OpCreate)
	return &CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Company entities.
func (c *CompanyClient) CreateBulk(builders ...*CompanyCreate) *CompanyCreateBulk {
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Company.
func (c *CompanyClient) Update() *CompanyUpdate {
	mutation := newCompanyMutation(c.config, OpUpdate)
	return &CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyClient) UpdateOne(co *Company) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompany(co))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyClient) UpdateOneID(id int) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompanyID(id))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Company.
func (c *CompanyClient) Delete() *CompanyDelete {
	mutation := newCompanyMutation(c.config, OpDelete)
	return &CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyClient) DeleteOne(co *Company) *CompanyDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyClient) DeleteOneID(id int) *CompanyDeleteOne {
	builder := c.Delete().Where(company.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyDeleteOne{builder}
}

// Query returns a query builder for Company.
func (c *CompanyClient) Query() *CompanyQuery {
	return &CompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a Company entity by its id.
func (c *CompanyClient) Get(ctx context.Context, id int) (*Company, error) {
	return c.Query().Where(company.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyClient) GetX(ctx context.Context, id int) *Company {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CompanyClient) Hooks() []Hook {
	return c.hooks.Company
}

// Interceptors returns the client interceptors.
func (c *CompanyClient) Interceptors() []Interceptor {
	return c.inters.Company
}

func (c *CompanyClient) mutate(ctx context.Context, m *CompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Company mutation op: %q", m.Op())
	}
}

// ProductBrandsClient is a client for the ProductBrands schema.
type ProductBrandsClient struct {
	config
}

// NewProductBrandsClient returns a client for the ProductBrands from the given config.
func NewProductBrandsClient(c config) *ProductBrandsClient {
	return &ProductBrandsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productbrands.Hooks(f(g(h())))`.
func (c *ProductBrandsClient) Use(hooks ...Hook) {
	c.hooks.ProductBrands = append(c.hooks.ProductBrands, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productbrands.Intercept(f(g(h())))`.
func (c *ProductBrandsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductBrands = append(c.inters.ProductBrands, interceptors...)
}

// Create returns a builder for creating a ProductBrands entity.
func (c *ProductBrandsClient) Create() *ProductBrandsCreate {
	mutation := newProductBrandsMutation(c.config, OpCreate)
	return &ProductBrandsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductBrands entities.
func (c *ProductBrandsClient) CreateBulk(builders ...*ProductBrandsCreate) *ProductBrandsCreateBulk {
	return &ProductBrandsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductBrands.
func (c *ProductBrandsClient) Update() *ProductBrandsUpdate {
	mutation := newProductBrandsMutation(c.config, OpUpdate)
	return &ProductBrandsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductBrandsClient) UpdateOne(pb *ProductBrands) *ProductBrandsUpdateOne {
	mutation := newProductBrandsMutation(c.config, OpUpdateOne, withProductBrands(pb))
	return &ProductBrandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductBrandsClient) UpdateOneID(id int) *ProductBrandsUpdateOne {
	mutation := newProductBrandsMutation(c.config, OpUpdateOne, withProductBrandsID(id))
	return &ProductBrandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductBrands.
func (c *ProductBrandsClient) Delete() *ProductBrandsDelete {
	mutation := newProductBrandsMutation(c.config, OpDelete)
	return &ProductBrandsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductBrandsClient) DeleteOne(pb *ProductBrands) *ProductBrandsDeleteOne {
	return c.DeleteOneID(pb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductBrandsClient) DeleteOneID(id int) *ProductBrandsDeleteOne {
	builder := c.Delete().Where(productbrands.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductBrandsDeleteOne{builder}
}

// Query returns a query builder for ProductBrands.
func (c *ProductBrandsClient) Query() *ProductBrandsQuery {
	return &ProductBrandsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductBrands},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductBrands entity by its id.
func (c *ProductBrandsClient) Get(ctx context.Context, id int) (*ProductBrands, error) {
	return c.Query().Where(productbrands.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductBrandsClient) GetX(ctx context.Context, id int) *ProductBrands {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductBrandsClient) Hooks() []Hook {
	return c.hooks.ProductBrands
}

// Interceptors returns the client interceptors.
func (c *ProductBrandsClient) Interceptors() []Interceptor {
	return c.inters.ProductBrands
}

func (c *ProductBrandsClient) mutate(ctx context.Context, m *ProductBrandsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductBrandsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductBrandsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductBrandsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductBrandsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductBrands mutation op: %q", m.Op())
	}
}

// ProductCategoriesClient is a client for the ProductCategories schema.
type ProductCategoriesClient struct {
	config
}

// NewProductCategoriesClient returns a client for the ProductCategories from the given config.
func NewProductCategoriesClient(c config) *ProductCategoriesClient {
	return &ProductCategoriesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productcategories.Hooks(f(g(h())))`.
func (c *ProductCategoriesClient) Use(hooks ...Hook) {
	c.hooks.ProductCategories = append(c.hooks.ProductCategories, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productcategories.Intercept(f(g(h())))`.
func (c *ProductCategoriesClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductCategories = append(c.inters.ProductCategories, interceptors...)
}

// Create returns a builder for creating a ProductCategories entity.
func (c *ProductCategoriesClient) Create() *ProductCategoriesCreate {
	mutation := newProductCategoriesMutation(c.config, OpCreate)
	return &ProductCategoriesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductCategories entities.
func (c *ProductCategoriesClient) CreateBulk(builders ...*ProductCategoriesCreate) *ProductCategoriesCreateBulk {
	return &ProductCategoriesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductCategories.
func (c *ProductCategoriesClient) Update() *ProductCategoriesUpdate {
	mutation := newProductCategoriesMutation(c.config, OpUpdate)
	return &ProductCategoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductCategoriesClient) UpdateOne(pc *ProductCategories) *ProductCategoriesUpdateOne {
	mutation := newProductCategoriesMutation(c.config, OpUpdateOne, withProductCategories(pc))
	return &ProductCategoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductCategoriesClient) UpdateOneID(id int) *ProductCategoriesUpdateOne {
	mutation := newProductCategoriesMutation(c.config, OpUpdateOne, withProductCategoriesID(id))
	return &ProductCategoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductCategories.
func (c *ProductCategoriesClient) Delete() *ProductCategoriesDelete {
	mutation := newProductCategoriesMutation(c.config, OpDelete)
	return &ProductCategoriesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductCategoriesClient) DeleteOne(pc *ProductCategories) *ProductCategoriesDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductCategoriesClient) DeleteOneID(id int) *ProductCategoriesDeleteOne {
	builder := c.Delete().Where(productcategories.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductCategoriesDeleteOne{builder}
}

// Query returns a query builder for ProductCategories.
func (c *ProductCategoriesClient) Query() *ProductCategoriesQuery {
	return &ProductCategoriesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductCategories},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductCategories entity by its id.
func (c *ProductCategoriesClient) Get(ctx context.Context, id int) (*ProductCategories, error) {
	return c.Query().Where(productcategories.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductCategoriesClient) GetX(ctx context.Context, id int) *ProductCategories {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductCategoriesClient) Hooks() []Hook {
	return c.hooks.ProductCategories
}

// Interceptors returns the client interceptors.
func (c *ProductCategoriesClient) Interceptors() []Interceptor {
	return c.inters.ProductCategories
}

func (c *ProductCategoriesClient) mutate(ctx context.Context, m *ProductCategoriesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCategoriesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductCategoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductCategoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductCategoriesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductCategories mutation op: %q", m.Op())
	}
}

// ProductColorsClient is a client for the ProductColors schema.
type ProductColorsClient struct {
	config
}

// NewProductColorsClient returns a client for the ProductColors from the given config.
func NewProductColorsClient(c config) *ProductColorsClient {
	return &ProductColorsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productcolors.Hooks(f(g(h())))`.
func (c *ProductColorsClient) Use(hooks ...Hook) {
	c.hooks.ProductColors = append(c.hooks.ProductColors, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productcolors.Intercept(f(g(h())))`.
func (c *ProductColorsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductColors = append(c.inters.ProductColors, interceptors...)
}

// Create returns a builder for creating a ProductColors entity.
func (c *ProductColorsClient) Create() *ProductColorsCreate {
	mutation := newProductColorsMutation(c.config, OpCreate)
	return &ProductColorsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductColors entities.
func (c *ProductColorsClient) CreateBulk(builders ...*ProductColorsCreate) *ProductColorsCreateBulk {
	return &ProductColorsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductColors.
func (c *ProductColorsClient) Update() *ProductColorsUpdate {
	mutation := newProductColorsMutation(c.config, OpUpdate)
	return &ProductColorsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductColorsClient) UpdateOne(pc *ProductColors) *ProductColorsUpdateOne {
	mutation := newProductColorsMutation(c.config, OpUpdateOne, withProductColors(pc))
	return &ProductColorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductColorsClient) UpdateOneID(id int) *ProductColorsUpdateOne {
	mutation := newProductColorsMutation(c.config, OpUpdateOne, withProductColorsID(id))
	return &ProductColorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductColors.
func (c *ProductColorsClient) Delete() *ProductColorsDelete {
	mutation := newProductColorsMutation(c.config, OpDelete)
	return &ProductColorsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductColorsClient) DeleteOne(pc *ProductColors) *ProductColorsDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductColorsClient) DeleteOneID(id int) *ProductColorsDeleteOne {
	builder := c.Delete().Where(productcolors.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductColorsDeleteOne{builder}
}

// Query returns a query builder for ProductColors.
func (c *ProductColorsClient) Query() *ProductColorsQuery {
	return &ProductColorsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductColors},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductColors entity by its id.
func (c *ProductColorsClient) Get(ctx context.Context, id int) (*ProductColors, error) {
	return c.Query().Where(productcolors.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductColorsClient) GetX(ctx context.Context, id int) *ProductColors {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductColorsClient) Hooks() []Hook {
	return c.hooks.ProductColors
}

// Interceptors returns the client interceptors.
func (c *ProductColorsClient) Interceptors() []Interceptor {
	return c.inters.ProductColors
}

func (c *ProductColorsClient) mutate(ctx context.Context, m *ProductColorsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductColorsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductColorsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductColorsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductColorsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductColors mutation op: %q", m.Op())
	}
}

// ProductSizesClient is a client for the ProductSizes schema.
type ProductSizesClient struct {
	config
}

// NewProductSizesClient returns a client for the ProductSizes from the given config.
func NewProductSizesClient(c config) *ProductSizesClient {
	return &ProductSizesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productsizes.Hooks(f(g(h())))`.
func (c *ProductSizesClient) Use(hooks ...Hook) {
	c.hooks.ProductSizes = append(c.hooks.ProductSizes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productsizes.Intercept(f(g(h())))`.
func (c *ProductSizesClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductSizes = append(c.inters.ProductSizes, interceptors...)
}

// Create returns a builder for creating a ProductSizes entity.
func (c *ProductSizesClient) Create() *ProductSizesCreate {
	mutation := newProductSizesMutation(c.config, OpCreate)
	return &ProductSizesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductSizes entities.
func (c *ProductSizesClient) CreateBulk(builders ...*ProductSizesCreate) *ProductSizesCreateBulk {
	return &ProductSizesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductSizes.
func (c *ProductSizesClient) Update() *ProductSizesUpdate {
	mutation := newProductSizesMutation(c.config, OpUpdate)
	return &ProductSizesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductSizesClient) UpdateOne(ps *ProductSizes) *ProductSizesUpdateOne {
	mutation := newProductSizesMutation(c.config, OpUpdateOne, withProductSizes(ps))
	return &ProductSizesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductSizesClient) UpdateOneID(id int) *ProductSizesUpdateOne {
	mutation := newProductSizesMutation(c.config, OpUpdateOne, withProductSizesID(id))
	return &ProductSizesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductSizes.
func (c *ProductSizesClient) Delete() *ProductSizesDelete {
	mutation := newProductSizesMutation(c.config, OpDelete)
	return &ProductSizesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductSizesClient) DeleteOne(ps *ProductSizes) *ProductSizesDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductSizesClient) DeleteOneID(id int) *ProductSizesDeleteOne {
	builder := c.Delete().Where(productsizes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductSizesDeleteOne{builder}
}

// Query returns a query builder for ProductSizes.
func (c *ProductSizesClient) Query() *ProductSizesQuery {
	return &ProductSizesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductSizes},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductSizes entity by its id.
func (c *ProductSizesClient) Get(ctx context.Context, id int) (*ProductSizes, error) {
	return c.Query().Where(productsizes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductSizesClient) GetX(ctx context.Context, id int) *ProductSizes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductSizesClient) Hooks() []Hook {
	return c.hooks.ProductSizes
}

// Interceptors returns the client interceptors.
func (c *ProductSizesClient) Interceptors() []Interceptor {
	return c.inters.ProductSizes
}

func (c *ProductSizesClient) mutate(ctx context.Context, m *ProductSizesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductSizesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductSizesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductSizesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductSizesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductSizes mutation op: %q", m.Op())
	}
}

// ProductStockClient is a client for the ProductStock schema.
type ProductStockClient struct {
	config
}

// NewProductStockClient returns a client for the ProductStock from the given config.
func NewProductStockClient(c config) *ProductStockClient {
	return &ProductStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productstock.Hooks(f(g(h())))`.
func (c *ProductStockClient) Use(hooks ...Hook) {
	c.hooks.ProductStock = append(c.hooks.ProductStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productstock.Intercept(f(g(h())))`.
func (c *ProductStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductStock = append(c.inters.ProductStock, interceptors...)
}

// Create returns a builder for creating a ProductStock entity.
func (c *ProductStockClient) Create() *ProductStockCreate {
	mutation := newProductStockMutation(c.config, OpCreate)
	return &ProductStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductStock entities.
func (c *ProductStockClient) CreateBulk(builders ...*ProductStockCreate) *ProductStockCreateBulk {
	return &ProductStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductStock.
func (c *ProductStockClient) Update() *ProductStockUpdate {
	mutation := newProductStockMutation(c.config, OpUpdate)
	return &ProductStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductStockClient) UpdateOne(ps *ProductStock) *ProductStockUpdateOne {
	mutation := newProductStockMutation(c.config, OpUpdateOne, withProductStock(ps))
	return &ProductStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductStockClient) UpdateOneID(id int) *ProductStockUpdateOne {
	mutation := newProductStockMutation(c.config, OpUpdateOne, withProductStockID(id))
	return &ProductStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductStock.
func (c *ProductStockClient) Delete() *ProductStockDelete {
	mutation := newProductStockMutation(c.config, OpDelete)
	return &ProductStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductStockClient) DeleteOne(ps *ProductStock) *ProductStockDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductStockClient) DeleteOneID(id int) *ProductStockDeleteOne {
	builder := c.Delete().Where(productstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductStockDeleteOne{builder}
}

// Query returns a query builder for ProductStock.
func (c *ProductStockClient) Query() *ProductStockQuery {
	return &ProductStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductStock},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductStock entity by its id.
func (c *ProductStockClient) Get(ctx context.Context, id int) (*ProductStock, error) {
	return c.Query().Where(productstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductStockClient) GetX(ctx context.Context, id int) *ProductStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductStockClient) Hooks() []Hook {
	return c.hooks.ProductStock
}

// Interceptors returns the client interceptors.
func (c *ProductStockClient) Interceptors() []Interceptor {
	return c.inters.ProductStock
}

func (c *ProductStockClient) mutate(ctx context.Context, m *ProductStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductStock mutation op: %q", m.Op())
	}
}

// ProductsClient is a client for the Products schema.
type ProductsClient struct {
	config
}

// NewProductsClient returns a client for the Products from the given config.
func NewProductsClient(c config) *ProductsClient {
	return &ProductsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `products.Hooks(f(g(h())))`.
func (c *ProductsClient) Use(hooks ...Hook) {
	c.hooks.Products = append(c.hooks.Products, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `products.Intercept(f(g(h())))`.
func (c *ProductsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Products = append(c.inters.Products, interceptors...)
}

// Create returns a builder for creating a Products entity.
func (c *ProductsClient) Create() *ProductsCreate {
	mutation := newProductsMutation(c.config, OpCreate)
	return &ProductsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Products entities.
func (c *ProductsClient) CreateBulk(builders ...*ProductsCreate) *ProductsCreateBulk {
	return &ProductsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Products.
func (c *ProductsClient) Update() *ProductsUpdate {
	mutation := newProductsMutation(c.config, OpUpdate)
	return &ProductsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductsClient) UpdateOne(pr *Products) *ProductsUpdateOne {
	mutation := newProductsMutation(c.config, OpUpdateOne, withProducts(pr))
	return &ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductsClient) UpdateOneID(id int) *ProductsUpdateOne {
	mutation := newProductsMutation(c.config, OpUpdateOne, withProductsID(id))
	return &ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Products.
func (c *ProductsClient) Delete() *ProductsDelete {
	mutation := newProductsMutation(c.config, OpDelete)
	return &ProductsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductsClient) DeleteOne(pr *Products) *ProductsDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductsClient) DeleteOneID(id int) *ProductsDeleteOne {
	builder := c.Delete().Where(products.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductsDeleteOne{builder}
}

// Query returns a query builder for Products.
func (c *ProductsClient) Query() *ProductsQuery {
	return &ProductsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProducts},
		inters: c.Interceptors(),
	}
}

// Get returns a Products entity by its id.
func (c *ProductsClient) Get(ctx context.Context, id int) (*Products, error) {
	return c.Query().Where(products.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductsClient) GetX(ctx context.Context, id int) *Products {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductsClient) Hooks() []Hook {
	return c.hooks.Products
}

// Interceptors returns the client interceptors.
func (c *ProductsClient) Interceptors() []Interceptor {
	return c.inters.Products
}

func (c *ProductsClient) mutate(ctx context.Context, m *ProductsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Products mutation op: %q", m.Op())
	}
}

// ReviewsClient is a client for the Reviews schema.
type ReviewsClient struct {
	config
}

// NewReviewsClient returns a client for the Reviews from the given config.
func NewReviewsClient(c config) *ReviewsClient {
	return &ReviewsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reviews.Hooks(f(g(h())))`.
func (c *ReviewsClient) Use(hooks ...Hook) {
	c.hooks.Reviews = append(c.hooks.Reviews, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reviews.Intercept(f(g(h())))`.
func (c *ReviewsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reviews = append(c.inters.Reviews, interceptors...)
}

// Create returns a builder for creating a Reviews entity.
func (c *ReviewsClient) Create() *ReviewsCreate {
	mutation := newReviewsMutation(c.config, OpCreate)
	return &ReviewsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reviews entities.
func (c *ReviewsClient) CreateBulk(builders ...*ReviewsCreate) *ReviewsCreateBulk {
	return &ReviewsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reviews.
func (c *ReviewsClient) Update() *ReviewsUpdate {
	mutation := newReviewsMutation(c.config, OpUpdate)
	return &ReviewsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReviewsClient) UpdateOne(r *Reviews) *ReviewsUpdateOne {
	mutation := newReviewsMutation(c.config, OpUpdateOne, withReviews(r))
	return &ReviewsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReviewsClient) UpdateOneID(id int) *ReviewsUpdateOne {
	mutation := newReviewsMutation(c.config, OpUpdateOne, withReviewsID(id))
	return &ReviewsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reviews.
func (c *ReviewsClient) Delete() *ReviewsDelete {
	mutation := newReviewsMutation(c.config, OpDelete)
	return &ReviewsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReviewsClient) DeleteOne(r *Reviews) *ReviewsDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReviewsClient) DeleteOneID(id int) *ReviewsDeleteOne {
	builder := c.Delete().Where(reviews.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReviewsDeleteOne{builder}
}

// Query returns a query builder for Reviews.
func (c *ReviewsClient) Query() *ReviewsQuery {
	return &ReviewsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReviews},
		inters: c.Interceptors(),
	}
}

// Get returns a Reviews entity by its id.
func (c *ReviewsClient) Get(ctx context.Context, id int) (*Reviews, error) {
	return c.Query().Where(reviews.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReviewsClient) GetX(ctx context.Context, id int) *Reviews {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Reviews.
func (c *ReviewsClient) QueryUser(r *Reviews) *UsersQuery {
	query := (&UsersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reviews.Table, reviews.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, reviews.UserTable, reviews.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReviewsClient) Hooks() []Hook {
	return c.hooks.Reviews
}

// Interceptors returns the client interceptors.
func (c *ReviewsClient) Interceptors() []Interceptor {
	return c.inters.Reviews
}

func (c *ReviewsClient) mutate(ctx context.Context, m *ReviewsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReviewsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReviewsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReviewsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReviewsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reviews mutation op: %q", m.Op())
	}
}

// ShopsClient is a client for the Shops schema.
type ShopsClient struct {
	config
}

// NewShopsClient returns a client for the Shops from the given config.
func NewShopsClient(c config) *ShopsClient {
	return &ShopsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `shops.Hooks(f(g(h())))`.
func (c *ShopsClient) Use(hooks ...Hook) {
	c.hooks.Shops = append(c.hooks.Shops, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `shops.Intercept(f(g(h())))`.
func (c *ShopsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Shops = append(c.inters.Shops, interceptors...)
}

// Create returns a builder for creating a Shops entity.
func (c *ShopsClient) Create() *ShopsCreate {
	mutation := newShopsMutation(c.config, OpCreate)
	return &ShopsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Shops entities.
func (c *ShopsClient) CreateBulk(builders ...*ShopsCreate) *ShopsCreateBulk {
	return &ShopsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Shops.
func (c *ShopsClient) Update() *ShopsUpdate {
	mutation := newShopsMutation(c.config, OpUpdate)
	return &ShopsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShopsClient) UpdateOne(s *Shops) *ShopsUpdateOne {
	mutation := newShopsMutation(c.config, OpUpdateOne, withShops(s))
	return &ShopsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShopsClient) UpdateOneID(id int) *ShopsUpdateOne {
	mutation := newShopsMutation(c.config, OpUpdateOne, withShopsID(id))
	return &ShopsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Shops.
func (c *ShopsClient) Delete() *ShopsDelete {
	mutation := newShopsMutation(c.config, OpDelete)
	return &ShopsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShopsClient) DeleteOne(s *Shops) *ShopsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShopsClient) DeleteOneID(id int) *ShopsDeleteOne {
	builder := c.Delete().Where(shops.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShopsDeleteOne{builder}
}

// Query returns a query builder for Shops.
func (c *ShopsClient) Query() *ShopsQuery {
	return &ShopsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShops},
		inters: c.Interceptors(),
	}
}

// Get returns a Shops entity by its id.
func (c *ShopsClient) Get(ctx context.Context, id int) (*Shops, error) {
	return c.Query().Where(shops.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShopsClient) GetX(ctx context.Context, id int) *Shops {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ShopsClient) Hooks() []Hook {
	return c.hooks.Shops
}

// Interceptors returns the client interceptors.
func (c *ShopsClient) Interceptors() []Interceptor {
	return c.inters.Shops
}

func (c *ShopsClient) mutate(ctx context.Context, m *ShopsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShopsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShopsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShopsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShopsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Shops mutation op: %q", m.Op())
	}
}

// UsersClient is a client for the Users schema.
type UsersClient struct {
	config
}

// NewUsersClient returns a client for the Users from the given config.
func NewUsersClient(c config) *UsersClient {
	return &UsersClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `users.Hooks(f(g(h())))`.
func (c *UsersClient) Use(hooks ...Hook) {
	c.hooks.Users = append(c.hooks.Users, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `users.Intercept(f(g(h())))`.
func (c *UsersClient) Intercept(interceptors ...Interceptor) {
	c.inters.Users = append(c.inters.Users, interceptors...)
}

// Create returns a builder for creating a Users entity.
func (c *UsersClient) Create() *UsersCreate {
	mutation := newUsersMutation(c.config, OpCreate)
	return &UsersCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Users entities.
func (c *UsersClient) CreateBulk(builders ...*UsersCreate) *UsersCreateBulk {
	return &UsersCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Users.
func (c *UsersClient) Update() *UsersUpdate {
	mutation := newUsersMutation(c.config, OpUpdate)
	return &UsersUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsersClient) UpdateOne(u *Users) *UsersUpdateOne {
	mutation := newUsersMutation(c.config, OpUpdateOne, withUsers(u))
	return &UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsersClient) UpdateOneID(id int) *UsersUpdateOne {
	mutation := newUsersMutation(c.config, OpUpdateOne, withUsersID(id))
	return &UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Users.
func (c *UsersClient) Delete() *UsersDelete {
	mutation := newUsersMutation(c.config, OpDelete)
	return &UsersDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsersClient) DeleteOne(u *Users) *UsersDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsersClient) DeleteOneID(id int) *UsersDeleteOne {
	builder := c.Delete().Where(users.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsersDeleteOne{builder}
}

// Query returns a query builder for Users.
func (c *UsersClient) Query() *UsersQuery {
	return &UsersQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsers},
		inters: c.Interceptors(),
	}
}

// Get returns a Users entity by its id.
func (c *UsersClient) Get(ctx context.Context, id int) (*Users, error) {
	return c.Query().Where(users.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsersClient) GetX(ctx context.Context, id int) *Users {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReviews queries the reviews edge of a Users.
func (c *UsersClient) QueryReviews(u *Users) *ReviewsQuery {
	query := (&ReviewsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(reviews.Table, reviews.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.ReviewsTable, users.ReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsersClient) Hooks() []Hook {
	hooks := c.hooks.Users
	return append(hooks[:len(hooks):len(hooks)], users.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UsersClient) Interceptors() []Interceptor {
	return c.inters.Users
}

func (c *UsersClient) mutate(ctx context.Context, m *UsersMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsersCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsersUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsersDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Users mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Admins, Company, ProductBrands, ProductCategories, ProductColors, ProductSizes,
		ProductStock, Products, Reviews, Shops, Users []ent.Hook
	}
	inters struct {
		Admins, Company, ProductBrands, ProductCategories, ProductColors, ProductSizes,
		ProductStock, Products, Reviews, Shops, Users []ent.Interceptor
	}
)
